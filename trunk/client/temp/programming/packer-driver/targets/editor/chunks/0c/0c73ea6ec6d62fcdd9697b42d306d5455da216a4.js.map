{"version":3,"sources":["file:///F:/TON-Game/src/trunk/client/assets/scripts/tongame/task/NestableScrollViewOuter.ts"],"names":["_decorator","ScrollView","v2","NestableScrollViewInner","ccclass","property","_tempVec2","_tempVec2_1","NestableScrollViewOuter","m_PlanDir","m_ScrollingInnerSv"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAQA,MAAAA,U,OAAAA,U;AAAoDC,MAAAA,U,OAAAA,U;AAAsCC,MAAAA,E,OAAAA,E;;AACzFC,MAAAA,uB,iBAAAA,uB;;;;;;;;;OAGH;AAACC,QAAAA,OAAD;AAAUC,QAAAA;AAAV,O,GAAsBL,U;AAEtBM,MAAAA,S,GAAYJ,EAAE,E;AACdK,MAAAA,W,GAAcL,EAAE,E;;yCAGTM,uB,WADZJ,OAAO,CAAC,yBAAD,C,UAKHC,QAAQ;AAAA;AAAA,6D,2BALb,MACaG,uBADb,SAC6CP,UAD7C,CACwD;AAAA;AAAA;AAAA,eAE5CQ,SAF4C,GAEvB,CAAC,CAFsB;;AAAA;;AAAA,eAO5CC,kBAP4C,GAOG,IAPH;AAAA;AAQxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AA/HwD,O;;;;;iBAKE,I","sourcesContent":["import {_decorator, Label, Sprite, math, SpriteFrame, Node, ScrollView, EventTouch, Event, Input, v2} from 'cc';\r\nimport { NestableScrollViewInner } from \"./NestableScrollViewInner\";\r\n\r\n\r\nconst {ccclass, property} = _decorator;\r\n\r\nconst _tempVec2 = v2();\r\nconst _tempVec2_1 = v2();\r\n\r\n@ccclass('NestableScrollViewOuter')\r\nexport class NestableScrollViewOuter extends ScrollView {\r\n\r\n    private m_PlanDir : number = -1;\r\n\r\n    @property(NestableScrollViewInner)\r\n    private m_InnerScrollView : NestableScrollViewInner = null;\r\n\r\n    private m_ScrollingInnerSv : NestableScrollViewInner = null;\r\n/*\r\n    //是否为子物体\r\n    //注意，这里递归, 如果child藏的太深, 可能影响效率。其实也还好，只是开始滑动时执行一次。\r\n    _isHisChild(child:Node, undeterminedParent:Node) {\r\n        if (child == undeterminedParent) {\r\n            return true;\r\n        }\r\n        if (child.parent != null) {\r\n            if (child.parent == undeterminedParent) {\r\n                return true;\r\n            } else {\r\n                return this._isHisChild(child.parent, undeterminedParent);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    //判断Target是否是InnerScrollView的子物体, 如果是，就返回这个InnerScrollView。\r\n    //注意，这里遍历所有InnerScrollView, 如果InnerScrollView数量太多，可能影响效率。其实也还好，只是开始滑动时执行一次。\r\n    _findScrollingInnerSv(target) : NestableScrollViewInner\r\n    {\r\n        if (this.m_InnerScrollView)\r\n        {\r\n            let isHisChild = this._isHisChild(target, this.m_InnerScrollView.node);\r\n            if (isHisChild) {\r\n                return this.m_InnerScrollView;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    //检查实际与计划方向的一致性\r\n    isDifferentBetweenSettingAndPlan(sv) {\r\n        if (this.m_PlanDir == 0) {\r\n            return false;\r\n        }\r\n        if (this.m_PlanDir == 1 && sv.horizontal) {\r\n            return false;\r\n        }\r\n        if (this.m_PlanDir == -1 && sv.vertical) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //#region 重写cc.ScrollView的方法\r\n    protected _hasNestedViewGroup(event: Event, captureListeners?: Node[]): boolean\r\n    {\r\n        if (event.eventPhase !== Event.CAPTURING_PHASE) return;\r\n        //不阻止out上onTouch事件执行。\r\n        return false;\r\n    }\r\n\r\n\r\n    protected _onTouchMoved(event: EventTouch, captureListeners?: Node[]): void\r\n    {\r\n        if (!this.enabledInHierarchy || !this._content) {\r\n            return;\r\n        }\r\n        if (this._hasNestedViewGroup(event, captureListeners)) {\r\n            return;\r\n        }\r\n\r\n        const touch = event.touch!;\r\n        this._handleMoveLogic(touch);\r\n\r\n        // Do not prevent touch events in inner nodes\r\n        if (!this.cancelInnerEvents) {\r\n            return;\r\n        }\r\n\r\n        const deltaMove = touch.getUILocation(_tempVec2);\r\n        deltaMove.subtract(touch.getUIStartLocation(_tempVec2_1));\r\n\r\n\r\n        //在滑动时, 设置开始时滑动的方向为计划方向\r\n        //为什么在Outer中做这件事？\r\n        //因为Outer的_onTouchMoved比Inner的早执行, 如果在Inner里做, Outer中就得忽略一帧，体验可能会不好。\r\n        if (this.m_PlanDir == null && deltaMove.length() > 7) {\r\n            this.m_ScrollingInnerSv = this._findScrollingInnerSv(event.target);\r\n            if (this.m_ScrollingInnerSv != null) {\r\n                let contentSize = this.m_ScrollingInnerSv.content.size;\r\n                let scrollViewSize = this.m_ScrollingInnerSv.node.size;\r\n                if ((this.m_ScrollingInnerSv.vertical && (contentSize.height > scrollViewSize.height)) || (this.m_ScrollingInnerSv.horizontal && (contentSize.width > scrollViewSize.width))) {\r\n                    this.m_PlanDir = Math.abs(deltaMove.x) > Math.abs(deltaMove.y) ? 1 : -1;\r\n                } else {\r\n                    this.m_PlanDir = 0;\r\n                }\r\n            } else {\r\n                this.m_PlanDir = 0;\r\n            }\r\n        }\r\n\r\n        if (this.content) {\r\n            if (!this.isDifferentBetweenSettingAndPlan(this)) {\r\n                this._handleMoveLogic(touch);\r\n            }\r\n        }\r\n\r\n        if (!this.cancelInnerEvents) {\r\n            return;\r\n        }\r\n\r\n        //只取消会捕获事件的直接子物体(如Button)上的事件\r\n        if (this.m_ScrollingInnerSv == null) {\r\n            if (deltaMove.length() > 7) {\r\n                if (!this._touchMoved && event.target !== this.node) {\r\n                    var cancelEvent = new EventTouch(event.getTouches(), event.bubbles, Node.EventType.TOUCH_CANCEL);\r\n                    cancelEvent.type = Node.EventType.TOUCH_CANCEL;\r\n                    cancelEvent.touch = event.touch;\r\n                    cancelEvent.simulate = true;\r\n                    event.target.dispatchEvent(cancelEvent);\r\n                    this._touchMoved = true;\r\n                }\r\n            }\r\n            this._stopPropagationIfTargetIsMe(event);\r\n        }\r\n        \r\n    }\r\n    */\r\n}\r\n"]}