{"version":3,"sources":["file:///F:/TON-Game/src/trunk/client/assets/resources/libs/virtual_grid_list/image_cache.ts"],"names":["ImageCache","Component","SpriteFrame","error","GameUtils","_imgMap","_imgLoadingList","_loadImgDuration","_imgLoading","_cacheImage","cacheImage","value","getImage","key","get","clear","loadImage","uri","callback","list","imgMap","Map","frame","push","cb","loopLoadImage","duration","startTime","Date","getTime","length","data","pop","loadSingleImage","scheduleOnce","texture","err","asyncWrap","loadAsync","set"],"mappings":"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","sourcesContent":["import {Component, SpriteFrame, error} from \"cc\";\r\nimport GameUtils from \"../utils/utils\";\r\n\r\nexport type Texture2DMap = Map<string, SpriteFrame>;\r\n\r\ninterface LoadTaskItem {\r\n    uri: string;\r\n    cb: Function;\r\n}\r\n\r\ntype LoadTaskItemArray = Array<LoadTaskItem>;\r\n\r\nexport class ImageCache extends Component {\r\n    protected _imgMap: Texture2DMap;                // 图片缓存\r\n    protected _imgLoadingList: LoadTaskItemArray;   // 要加载的图片列表\r\n\r\n    protected _loadImgDuration: number = 1;         // 帧内加载最大时长\r\n\r\n    protected _imgLoading: boolean = false;         // 图片列表是否在加载中\r\n    protected _cacheImage: boolean = true;            // 缓存加载的图片\r\n\r\n    set cacheImage(value: boolean) {\r\n        this._cacheImage = value;\r\n    }\r\n\r\n    /**\r\n     * 获取缓存图片\r\n     * @param {String} key\r\n     * @returns {SpriteFrame} 纹理\r\n     */\r\n    public getImage(key: string): SpriteFrame {\r\n        return this._imgMap.get(key);\r\n    }\r\n\r\n    public clear() {\r\n        this._imgMap && this._imgMap.clear();\r\n        this._imgMap = null;\r\n    }\r\n\r\n    /**\r\n     * 添加并等待加载图片\r\n     * @param {String} uri 加载图片地址\r\n     * @param {Function} callback  加载完成回调方法\r\n     */\r\n    public loadImage(uri: string, callback: Function) {\r\n        let list = this._imgLoadingList;\r\n        let imgMap = this._imgMap;\r\n        if (!list) {\r\n            list = this._imgLoadingList = [];\r\n            imgMap = this._imgMap = new Map();\r\n        }\r\n\r\n        if (this._cacheImage) {\r\n            const frame = imgMap.get(uri);\r\n            if (frame && callback) {\r\n                callback(frame, uri);\r\n                return;\r\n            }\r\n        }\r\n        list.push({\r\n            uri: uri,\r\n            cb: callback\r\n        });\r\n        if (!this._imgLoading) {\r\n            this._imgLoading = true;\r\n            this.loopLoadImage(list, this._loadImgDuration, imgMap);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 循环排队加载图片列表\r\n     * @param {LoadTaskItemArray} list 要加载的图片列表 [{uri, cb, thisObj}]\r\n     * @param {Number} duration 帧内加载最大时长\r\n     * @param {Texture2DMap} imgMap 图片缓存map\r\n     */\r\n    public loopLoadImage(list: LoadTaskItemArray, duration: number, imgMap: Texture2DMap) {\r\n        // 执行之前，先记录开始时间\r\n        const startTime = new Date().getTime();\r\n        while (list.length > 0) {\r\n\r\n            let data = list.pop();\r\n            this.loadSingleImage(data.uri, data.cb, imgMap);\r\n\r\n            // 每执行完一段小代码段，都检查一下是否已经超过我们分配的本帧，这些小代码端的最大可执行时间\r\n            if (new Date().getTime() - startTime > duration) {\r\n                // 如果超过了，那么本帧就不在执行，开定时器，让下一帧再执行\r\n                this.scheduleOnce(() => {\r\n                    this.loopLoadImage(list, duration, imgMap);\r\n                });\r\n                return;\r\n            }\r\n        }\r\n        this._imgLoading = false;\r\n    }\r\n\r\n    /**\r\n     * 加载单张图片\r\n     * @param {String} uri 加载图片地址\r\n     * @param {Function} callback  加载完成回调方法\r\n     * @param {Texture2DMap} imgMap 图片缓存map\r\n     */\r\n    public async loadSingleImage(uri: string, callback: Function, imgMap: Texture2DMap) {\r\n        const [texture, err] = await GameUtils.asyncWrap<SpriteFrame, string>(GameUtils.loadAsync(uri + '/spriteFrame', SpriteFrame));\r\n        if (err) {\r\n            error('create sprite frame failed, err:' + err);\r\n            return false;\r\n        }\r\n\r\n        if (this._cacheImage) {\r\n            imgMap.set(uri, texture);\r\n        }\r\n\r\n        if (callback) {\r\n            callback(texture, uri);\r\n        }\r\n    }\r\n}\r\n"]}