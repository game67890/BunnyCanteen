{"version":3,"sources":["file:///F:/TON-Game/src/trunk/client/assets/resources/libs/utils/scene_manager.ts"],"names":["GameSceneManager","log","director","Singleton","StartSceneMode","constructor","_sceneStack","_curSceneName","_data","_isLoadingScene","_countDownTimer","_loadSceneTimeout","init","initSceneName","length","push","sceneName","isTempScene","getSceneStack","slice","getSceneData","getSceneName","startScene","options","TAG","nameArray","split","data","doStartScene","startMode","onSceneLaunched","err","backScene","sceneInfo","getBackSceneInfo","doGoBackScene","i","countDownLoadScene","isLoadSuccess","loadScene","handleStackByMode","cancelCountDownTimer","handleBackSceneStack","pop","STANDARD","isTemp","SINGLE_TOP","index","splice","CLEAR_STACK","TEMPORARY","setTimeout","clearTimeout"],"mappings":";;;yGA4BaA,gB;;;;;;;;;;;;;;;AA5BLC,MAAAA,G,OAAAA,G;AAAKC,MAAAA,Q,OAAAA,Q;;AACLC,MAAAA,S,iBAAAA,S;;;;;;;;;AAkBR;gCACYC,c,0BAAAA,c;AAAAA,QAAAA,c,CAAAA,c;AAAAA,QAAAA,c,CAAAA,c;AAAAA,QAAAA,c,CAAAA,c;AAAAA,QAAAA,c,CAAAA,c;eAAAA,c;cAOZ;;;kCACaJ,gB,GAAN,MAAMA,gBAAN,SAA+B;AAAA;AAAA,mCAA/B,CAA6D;AAYtDK,QAAAA,WAAW,GAAG;AACpB;AADoB,eAThBC,WASgB,GATW,EASX;AAAA,eARhBC,aAQgB;AAAA,eANhBC,KAMgB;AAAA,eAJhBC,eAIgB,GAJE,KAIF;AAAA,eAHhBC,eAGgB,GAHO,IAGP;AAAA,eAFhBC,iBAEgB,GAFI,KAAK,IAET;AAEvB;AAED;AACJ;AACA;AACA;AACA;;;AACWC,QAAAA,IAAI,CAACC,aAAD,EAAwB;AAC/B,cAAI,KAAKP,WAAL,CAAiBQ,MAAjB,IAA2B,CAA3B,IAAgCD,aAApC,EAAmD;AAC/C,iBAAKP,WAAL,CAAiBS,IAAjB,CAAsB;AAACC,cAAAA,SAAS,EAAEH,aAAZ;AAA2BI,cAAAA,WAAW,EAAE;AAAxC,aAAtB;AACH;AACJ;AAED;AACJ;AACA;;;AAC4B,YAAbC,aAAa,GAAgB;AACpC,iBAAO,KAAKZ,WAAL,CAAiBa,KAAjB,EAAP;AACH;AAED;AACJ;AACA;;;AAC2B,YAAZC,YAAY,GAAc;AACjC,iBAAO,KAAKZ,KAAZ;AACH;AAED;AACJ;AACA;;;AAC2B,YAAZa,YAAY,GAAW;AAC9B,iBAAO,KAAKd,aAAZ;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACWe,QAAAA,UAAU,CAACN,SAAD,EAAoBO,OAApB,EAAgD;AAC7D,cAAI,KAAKd,eAAT,EAA0B;AACtBR,YAAAA,GAAG,CAACD,gBAAgB,CAACwB,GAAlB,EAAuB,4CAAvB,CAAH;AACA;AACH;;AAED,cAAI;AACA,gBAAI,CAACR,SAAL,EAAgB;AACZ,mBAAKP,eAAL,GAAuB,KAAvB;AACA;AACH;;AAED,gBAAI,CAACc,OAAL,EAAc;AACVA,cAAAA,OAAO,GAAG,EAAV;AACH;;AACD,gBAAIE,SAAS,GAAGT,SAAS,CAACU,KAAV,CAAgB,GAAhB,CAAhB;AACAV,YAAAA,SAAS,GAAGS,SAAS,CAACA,SAAS,CAACX,MAAV,GAAmB,CAApB,CAArB;AACA,iBAAKL,eAAL,GAAuB,IAAvB;AACA,iBAAKD,KAAL,GAAae,OAAO,CAACI,IAArB;AACA,iBAAKC,YAAL,CAAkBZ,SAAlB,EAA6BO,OAAO,CAACM,SAArC,EAAgDN,OAAO,CAACO,eAAxD;AACH,WAdD,CAcE,OAAOC,GAAP,EAAY;AACV,iBAAKtB,eAAL,GAAuB,KAAvB;AACAR,YAAAA,GAAG,CAACD,gBAAgB,CAACwB,GAAlB,EAAuB,oBAAoBO,GAA3C,CAAH;AACH;AACJ;AAED;AACJ;AACA;AACA;;;AACWC,QAAAA,SAAS,CAACT,OAAD,EAAqC;AACjD,cAAI,KAAKd,eAAT,EAA0B;AACtBR,YAAAA,GAAG,CAACD,gBAAgB,CAACwB,GAAlB,EAAuB,iDAAvB,CAAH;AACA;AACH;;AACD,cAAI;AACA,gBAAI,KAAKlB,WAAL,CAAiBQ,MAAjB,IAA2B,CAA/B,EAAkC;AAC9Bb,cAAAA,GAAG,CAACD,gBAAgB,CAACwB,GAAlB,EAAuB,qBAAvB,CAAH;AACA,mBAAKf,eAAL,GAAuB,KAAvB;AACA,qBAAO,KAAP;AACH;;AAED,gBAAI,CAACc,OAAL,EAAc;AACVA,cAAAA,OAAO,GAAG,EAAV;AACH;;AAED,gBAAIU,SAAS,GAAG,KAAKC,gBAAL,EAAhB;;AACA,gBAAI,CAACD,SAAS,CAACjB,SAAf,EAA0B;AACtBf,cAAAA,GAAG,CAACD,gBAAgB,CAACwB,GAAlB,EAAuB,qCAAvB,CAAH;AACA;AACH;;AACD,iBAAKf,eAAL,GAAuB,IAAvB;AACA,iBAAKD,KAAL,GAAae,OAAO,CAACI,IAArB;AACA,iBAAKQ,aAAL,CAAmBF,SAAS,CAACjB,SAA7B,EAAwCO,OAAO,CAACO,eAAhD;AAEH,WApBD,CAoBE,OAAOC,GAAP,EAAY;AACV9B,YAAAA,GAAG,CAACD,gBAAgB,CAACwB,GAAlB,EAAuB,mBAAmBO,GAA1C,CAAH;AACA,iBAAKtB,eAAL,GAAuB,KAAvB;AACH;;AACD,iBAAO,IAAP;AACH;AAED;AACJ;AACA;;;AACYyB,QAAAA,gBAAgB,GAAc;AAClC,cAAID,SAAJ;;AACA,eAAK,IAAIG,CAAC,GAAG,KAAK9B,WAAL,CAAiBQ,MAAjB,GAA0B,CAAvC,EAA0CsB,CAAC,IAAI,CAA/C,EAAkDA,CAAC,EAAnD,EAAuD;AACnDH,YAAAA,SAAS,GAAG,KAAK3B,WAAL,CAAiB8B,CAAjB,CAAZ;;AACA,gBAAI,CAACH,SAAS,CAAChB,WAAf,EAA4B;AACxB;AACH;AACJ;;AACD,iBAAOgB,SAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACYL,QAAAA,YAAY,CAACZ,SAAD,EAAoBa,SAApB,EAAgDC,eAAhD,EAA4E;AAAA;;AAC5F,eAAKO,kBAAL;AACA,cAAIC,aAAa,GAAGpC,QAAQ,CAACqC,SAAT,CAAmBvB,SAAnB,EAA8B,YAAoB;AAClE,YAAA,KAAI,CAACwB,iBAAL,CAAuBxB,SAAvB,EAAkCa,SAAlC;;AACA,YAAA,KAAI,CAACtB,aAAL,GAAqBS,SAArB;AACA,YAAA,KAAI,CAACP,eAAL,GAAuB,KAAvB;AACAR,YAAAA,GAAG,CAACD,gBAAgB,CAACwB,GAAlB,EAAuB,kBAAvB,CAAH;;AACA,YAAA,KAAI,CAACiB,oBAAL;;AACA,gBAAIX,eAAJ,EAAqB;AACjBA,cAAAA,eAAe,CAAC,YAAD,CAAf;AACH;AACJ,WATmB,CAApB;AAUA7B,UAAAA,GAAG,CAACD,gBAAgB,CAACwB,GAAlB,EAAuBR,SAAS,GAAG,kBAAZ,GAAiCsB,aAAxD,CAAH;;AACA,cAAI,CAACA,aAAL,EAAoB;AAChB,iBAAK7B,eAAL,GAAuB,KAAvB;AACH;AACJ;AAED;AACJ;AACA;AACA;AACA;;;AACY0B,QAAAA,aAAa,CAACnB,SAAD,EAAoBc,eAApB,EAAgD;AAAA;;AACjE,eAAKO,kBAAL;AACA,cAAIC,aAAa,GAAGpC,QAAQ,CAACqC,SAAT,CAAmBvB,SAAnB,EAA8B,YAAoB;AAClE,YAAA,MAAI,CAACP,eAAL,GAAuB,KAAvB;;AACA,YAAA,MAAI,CAACgC,oBAAL;;AACAxC,YAAAA,GAAG,CAACD,gBAAgB,CAACwB,GAAlB,EAAuB,kBAAvB,CAAH;AACA,YAAA,MAAI,CAACjB,aAAL,GAAqBS,SAArB;;AACA,YAAA,MAAI,CAAC0B,oBAAL;;AACA,gBAAIZ,eAAJ,EAAqB;AACjBA,cAAAA,eAAe,CAAC,YAAD,CAAf;AACH;AACJ,WATmB,CAApB;AAUA7B,UAAAA,GAAG,CAACD,gBAAgB,CAACwB,GAAlB,EAAuB,yBAAyBR,SAAzB,GAAqC,GAArC,GAA2CsB,aAAlE,CAAH;;AACA,cAAI,CAACA,aAAL,EAAoB;AAChB,iBAAK7B,eAAL,GAAuB,KAAvB;AACH;AACJ;AAED;AACJ;AACA;;;AACYiC,QAAAA,oBAAoB,GAAG;AAC3B,eAAKpC,WAAL,CAAiBqC,GAAjB;;AAEA,cAAIV,SAAS,GAAG,KAAK3B,WAAL,CAAiB,KAAKA,WAAL,CAAiBQ,MAAjB,GAA0B,CAA3C,CAAhB;;AACA,iBAAOmB,SAAS,CAAChB,WAAjB,EAA8B;AAC1B,iBAAKX,WAAL,CAAiBqC,GAAjB;;AACAV,YAAAA,SAAS,GAAG,KAAK3B,WAAL,CAAiB,KAAKA,WAAL,CAAiBQ,MAAjB,GAA0B,CAA3C,CAAZ;AACH;AACJ;AAED;AACJ;AACA;AACA;AACA;;;AACY0B,QAAAA,iBAAiB,CAACxB,SAAD,EAAoBa,SAApB,EAAgD;AACrE,cAAI,CAACA,SAAL,EAAgB;AACZA,YAAAA,SAAS,GAAGzB,cAAc,CAACwC,QAA3B;AACH;;AACD,cAAIC,MAAM,GAAG,KAAb;;AACA,kBAAQhB,SAAR;AACI,iBAAKzB,cAAc,CAACwC,QAApB;AACI;;AACJ,iBAAKxC,cAAc,CAAC0C,UAApB;AACI,kBAAIC,KAAK,GAAG,CAAC,CAAb;;AACA,mBAAK,IAAIX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK9B,WAAL,CAAiBQ,MAArC,EAA6CsB,CAAC,EAA9C,EAAkD;AAC9C,oBAAIpB,SAAS,IAAI,KAAKV,WAAL,CAAiB8B,CAAjB,EAAoBpB,SAArC,EAAgD;AAC5C+B,kBAAAA,KAAK,GAAGX,CAAR;AACA;AACH;AACJ;;AACD,kBAAIW,KAAK,IAAI,CAAC,CAAd,EAAiB;AACb,qBAAKzC,WAAL,CAAiB0C,MAAjB,CAAwBD,KAAxB,EAA+B,KAAKzC,WAAL,CAAiBQ,MAAjB,GAA0BiC,KAAzD;AACH;;AACD;;AACJ,iBAAK3C,cAAc,CAAC6C,WAApB;AACI,mBAAK3C,WAAL,GAAmB,EAAnB;AACA;;AACJ,iBAAKF,cAAc,CAAC8C,SAApB;AACIL,cAAAA,MAAM,GAAG,IAAT;AACA;;AACJ;AArBJ;;AAwBA,eAAKvC,WAAL,CAAiBS,IAAjB,CAAsB;AAACC,YAAAA,SAAS,EAAEA,SAAZ;AAAuBC,YAAAA,WAAW,EAAE4B;AAApC,WAAtB;AACH;AAED;AACJ;AACA;;;AACYR,QAAAA,kBAAkB,GAAG;AACzBpC,UAAAA,GAAG,CAACD,gBAAgB,CAACwB,GAAlB,EAAuB,6BAAvB,CAAH;AACA,eAAKiB,oBAAL;AACA,eAAK/B,eAAL,GAAuByC,UAAU,CAAC,MAAM;AACpC,iBAAK1C,eAAL,GAAuB,KAAvB;AACAR,YAAAA,GAAG,CAACD,gBAAgB,CAACwB,GAAlB,EAAuB,mBAAvB,CAAH;AACA,iBAAKiB,oBAAL;AACH,WAJgC,EAI9B,KAAK9B,iBAJyB,CAAjC;AAKH;;AAEO8B,QAAAA,oBAAoB,GAAG;AAC3B,cAAI,KAAK/B,eAAT,EAA0B;AACtB0C,YAAAA,YAAY,CAAC,KAAK1C,eAAN,CAAZ;AACA,iBAAKA,eAAL,GAAuB,IAAvB;AACH;AACJ;;AApP+D,O;;AAAvDV,MAAAA,gB,CACMwB,G,GAAM,kB","sourcesContent":["import {log, director} from \"cc\";\r\nimport {Singleton} from \"./singleton\";\r\n\r\ntype SceneData = { [key: string]: any };\r\n\r\ninterface GameScene {\r\n    sceneName: string;\r\n    isTempScene: boolean;\r\n}\r\n\r\ninterface BackSceneOption {\r\n    data?: SceneData;\r\n    onSceneLaunched?: Function;\r\n}\r\n\r\ninterface StartSceneOption extends BackSceneOption {\r\n    startMode?: StartSceneMode;\r\n}\r\n\r\n// 启动场景的模式\r\nexport enum StartSceneMode {\r\n    STANDARD, // 标准模式：直接压栈\r\n    SINGLE_TOP, // 栈顶模式：如果存在，则清空在其之上的scene，然后压栈；否则直接压栈\r\n    CLEAR_STACK, // 清空栈，再压栈\r\n    TEMPORARY, // 临时场景：返回时会跳过这个场景\r\n}\r\n\r\n// 游戏场景管理器\r\nexport class GameSceneManager extends Singleton<GameSceneManager>() {\r\n    private static TAG = 'GameSceneManager';\r\n\r\n    private _sceneStack: GameScene[] = [];\r\n    private _curSceneName: string;\r\n\r\n    private _data: SceneData;\r\n\r\n    private _isLoadingScene = false;\r\n    private _countDownTimer: any = null;\r\n    private _loadSceneTimeout = 10 * 1000;\r\n\r\n    protected constructor() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * SceneManager 初始化\r\n     * 因为游戏默认启动一个场景，所以第一个场景并不是由 SceneManager 启动，所以通过此方法设定默认启动的场景\r\n     * @param initSceneName 第一个场景的场景名\r\n     */\r\n    public init(initSceneName: string) {\r\n        if (this._sceneStack.length == 0 && initSceneName) {\r\n            this._sceneStack.push({sceneName: initSceneName, isTempScene: false});\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取当前的场景栈\r\n     */\r\n    public get getSceneStack(): GameScene[] {\r\n        return this._sceneStack.slice();\r\n    }\r\n\r\n    /**\r\n     * 获取上一个场景传递过来的数据\r\n     */\r\n    public get getSceneData(): SceneData {\r\n        return this._data;\r\n    }\r\n\r\n    /**\r\n     * 获取当前场景名\r\n     */\r\n    public get getSceneName(): string {\r\n        return this._curSceneName;\r\n    }\r\n\r\n    /**\r\n     * @description 启动一个场景\r\n     * @param sceneName 要启动的场景名称\r\n     * @param options 要传递的数据\r\n     */\r\n    public startScene(sceneName: string, options?: StartSceneOption) {\r\n        if (this._isLoadingScene) {\r\n            log(GameSceneManager.TAG, 'It is loading scene now, skip this invoke.');\r\n            return;\r\n        }\r\n\r\n        try {\r\n            if (!sceneName) {\r\n                this._isLoadingScene = false;\r\n                return;\r\n            }\r\n\r\n            if (!options) {\r\n                options = {}\r\n            }\r\n            let nameArray = sceneName.split('/');\r\n            sceneName = nameArray[nameArray.length - 1];\r\n            this._isLoadingScene = true;\r\n            this._data = options.data;\r\n            this.doStartScene(sceneName, options.startMode, options.onSceneLaunched);\r\n        } catch (err) {\r\n            this._isLoadingScene = false;\r\n            log(GameSceneManager.TAG, 'startScene err=' + err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description 回到上一个场景\r\n     * @param options 需要传递给上一个场景的数据\r\n     */\r\n    public backScene(options?: BackSceneOption): boolean {\r\n        if (this._isLoadingScene) {\r\n            log(GameSceneManager.TAG, 'It is loading back scene now, skip this invoke.');\r\n            return;\r\n        }\r\n        try {\r\n            if (this._sceneStack.length <= 1) {\r\n                log(GameSceneManager.TAG, 'This is last scene.');\r\n                this._isLoadingScene = false;\r\n                return false;\r\n            }\r\n\r\n            if (!options) {\r\n                options = {}\r\n            }\r\n\r\n            let sceneInfo = this.getBackSceneInfo();\r\n            if (!sceneInfo.sceneName) {\r\n                log(GameSceneManager.TAG, 'backScene failed: sceneName is null');\r\n                return;\r\n            }\r\n            this._isLoadingScene = true;\r\n            this._data = options.data;\r\n            this.doGoBackScene(sceneInfo.sceneName, options.onSceneLaunched);\r\n\r\n        } catch (err) {\r\n            log(GameSceneManager.TAG, 'backscene err=' + err);\r\n            this._isLoadingScene = false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @description 获取返回的场景信息\r\n     */\r\n    private getBackSceneInfo(): GameScene {\r\n        let sceneInfo: GameScene;\r\n        for (let i = this._sceneStack.length - 2; i >= 0; i--) {\r\n            sceneInfo = this._sceneStack[i];\r\n            if (!sceneInfo.isTempScene) {\r\n                break;\r\n            }\r\n        }\r\n        return sceneInfo;\r\n    }\r\n\r\n    /**\r\n     * @description 开始启动场景，并处理场景栈\r\n     * @param sceneName 场景名\r\n     * @param startMode 启动模式\r\n     * @param onSceneLaunched 场景启动完成后的回调\r\n     */\r\n    private doStartScene(sceneName: string, startMode?: StartSceneMode, onSceneLaunched?: Function) {\r\n        this.countDownLoadScene();\r\n        let isLoadSuccess = director.loadScene(sceneName, (...args: any[]) => {\r\n            this.handleStackByMode(sceneName, startMode);\r\n            this._curSceneName = sceneName;\r\n            this._isLoadingScene = false;\r\n            log(GameSceneManager.TAG, 'loadScene Finish');\r\n            this.cancelCountDownTimer();\r\n            if (onSceneLaunched) {\r\n                onSceneLaunched(...args);\r\n            }\r\n        });\r\n        log(GameSceneManager.TAG, sceneName + ' isLoadSuccess: ' + isLoadSuccess);\r\n        if (!isLoadSuccess) {\r\n            this._isLoadingScene = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description 开始返回场景\r\n     * @param {String} sceneName 要返回的名字\r\n     * @param onSceneLaunched 返回场景成功后的回调\r\n     */\r\n    private doGoBackScene(sceneName: string, onSceneLaunched?: Function) {\r\n        this.countDownLoadScene();\r\n        let isLoadSuccess = director.loadScene(sceneName, (...args: any[]) => {\r\n            this._isLoadingScene = false;\r\n            this.cancelCountDownTimer();\r\n            log(GameSceneManager.TAG, 'backScene Finish');\r\n            this._curSceneName = sceneName;\r\n            this.handleBackSceneStack();\r\n            if (onSceneLaunched) {\r\n                onSceneLaunched(...args);\r\n            }\r\n        });\r\n        log(GameSceneManager.TAG, 'backScene isSuccess ' + sceneName + ' ' + isLoadSuccess);\r\n        if (!isLoadSuccess) {\r\n            this._isLoadingScene = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description 处理返回场景时的栈\r\n     */\r\n    private handleBackSceneStack() {\r\n        this._sceneStack.pop();\r\n\r\n        let sceneInfo = this._sceneStack[this._sceneStack.length - 1];\r\n        while (sceneInfo.isTempScene) {\r\n            this._sceneStack.pop();\r\n            sceneInfo = this._sceneStack[this._sceneStack.length - 1];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description 处理不同启动模式时的入栈情况\r\n     * @param sceneName 要入栈的scene名称\r\n     * @param startMode 启动模式\r\n     */\r\n    private handleStackByMode(sceneName: string, startMode?: StartSceneMode) {\r\n        if (!startMode) {\r\n            startMode = StartSceneMode.STANDARD;\r\n        }\r\n        let isTemp = false;\r\n        switch (startMode) {\r\n            case StartSceneMode.STANDARD:\r\n                break;\r\n            case StartSceneMode.SINGLE_TOP:\r\n                let index = -1;\r\n                for (let i = 0; i < this._sceneStack.length; i++) {\r\n                    if (sceneName == this._sceneStack[i].sceneName) {\r\n                        index = i;\r\n                        break;\r\n                    }\r\n                }\r\n                if (index != -1) {\r\n                    this._sceneStack.splice(index, this._sceneStack.length - index);\r\n                }\r\n                break;\r\n            case StartSceneMode.CLEAR_STACK:\r\n                this._sceneStack = [];\r\n                break;\r\n            case StartSceneMode.TEMPORARY:\r\n                isTemp = true;\r\n                break;\r\n            default:\r\n\r\n        }\r\n        this._sceneStack.push({sceneName: sceneName, isTempScene: isTemp});\r\n    }\r\n\r\n    /**\r\n     * @description 加载场景的计时器，防止加载一个场景卡死无回调时，SceneManager 无法启动其他场景的问题\r\n     */\r\n    private countDownLoadScene() {\r\n        log(GameSceneManager.TAG, 'begin count down loadScene.');\r\n        this.cancelCountDownTimer();\r\n        this._countDownTimer = setTimeout(() => {\r\n            this._isLoadingScene = false;\r\n            log(GameSceneManager.TAG, 'loadScene timeout');\r\n            this.cancelCountDownTimer();\r\n        }, this._loadSceneTimeout);\r\n    }\r\n\r\n    private cancelCountDownTimer() {\r\n        if (this._countDownTimer) {\r\n            clearTimeout(this._countDownTimer);\r\n            this._countDownTimer = null;\r\n        }\r\n    }\r\n}\r\n"]}